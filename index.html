<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEET DISCIPLINE DASHBOARD</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #e0e0e0;
            --accent-color: #ffffff;
            --highlight-bg: #1f1f1f;
            --border-color: #333;
            --dim-text: #666;
            --success-color: #4caf50;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace; /* Monospace for disciplined feel */
            height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr;
            overflow: hidden;
        }

        /* HEADER */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            border-bottom: 1px solid var(--border-color);
            background-color: #000;
        }

        #clock {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #progress-display {
            font-size: 1rem;
            color: var(--dim-text);
        }

        button.fs-btn {
            background: none;
            border: 1px solid var(--dim-text);
            color: var(--dim-text);
            padding: 5px 15px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        button.fs-btn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* MAIN LAYOUT */
        main {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100%;
            overflow: hidden;
        }

        /* SIDEBAR (SCHEDULE) */
        aside {
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 0;
        }

        .schedule-item {
            padding: 15px 20px;
            border-bottom: 1px solid #111;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background 0.3s;
            font-size: 0.9rem;
        }

        .schedule-item.active {
            background-color: var(--highlight-bg);
            border-left: 4px solid var(--accent-color);
            color: var(--accent-color);
        }

        .schedule-item.break {
            color: var(--dim-text);
            font-style: italic;
        }

        .schedule-item.completed {
            text-decoration: line-through;
            opacity: 0.5;
        }

        .time-col {
            min-width: 100px;
            font-weight: bold;
        }

        .task-col {
            flex-grow: 1;
            padding-left: 10px;
        }

        input[type="checkbox"] {
            accent-color: var(--text-color);
            transform: scale(1.2);
            cursor: pointer;
        }

        /* FOCUS ZONE */
        #focus-zone {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
        }

        #current-task-label {
            font-size: 1.5rem;
            color: var(--dim-text);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #current-task-name {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 40px;
            max-width: 80%;
        }

        #timer {
            font-size: 8rem;
            font-weight: 300;
            margin-bottom: 40px;
            font-variant-numeric: tabular-nums;
        }

        .timer-controls button {
            background: transparent;
            border: 2px solid var(--text-color);
            color: var(--text-color);
            font-size: 1.2rem;
            padding: 15px 40px;
            margin: 0 10px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .timer-controls button:hover {
            background: var(--text-color);
            color: var(--bg-color);
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #000;
        }
        ::-webkit-scrollbar-thumb {
            background: #333;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* UTILITIES */
        .blink {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% { opacity: 0; }
        }
    </style>
</head>
<body>

    <header>
        <div id="clock">00:00:00</div>
        <div class="header-controls">
            <span id="progress-display">Tasks: 0/0</span>
            <button class="fs-btn" onclick="toggleFullScreen()">[ ] Full Screen</button>
        </div>
    </header>

    <main>
        <aside id="schedule-list">
            </aside>

        <div id="focus-zone">
            <div id="current-task-label">Current Task</div>
            <div id="current-task-name">System Idle</div>

            <div id="timer">00:00</div>

            <div class="timer-controls">
                <button onclick="startTimer()">Start</button>
                <button onclick="pauseTimer()">Pause</button>
                <button onclick="resetTimer()">Reset</button>
            </div>
        </div>
    </main>

    <script>
        // --- CONFIGURATION & DATA ---

        // Define the schedule exactly as requested
        // Format: start (HH:MM), end (HH:MM), task, type (study/break)
        const rawSchedule = [
            // Morning - Biology
            { s: "08:45", e: "09:30", t: "Bio Lecture 1", type: "study" },
            { s: "09:30", e: "09:45", t: "Break", type: "break" },
            { s: "09:45", e: "10:30", t: "Bio QP + Revision", type: "study" },
            { s: "10:30", e: "10:45", t: "Break", type: "break" },
            { s: "10:45", e: "11:30", t: "Bio Lecture 2", type: "study" },
            { s: "11:30", e: "11:45", t: "Break", type: "break" },
            { s: "11:45", e: "12:30", t: "Bio QP + Revision", type: "study" },
            { s: "12:30", e: "12:45", t: "Break", type: "break" },
            { s: "12:45", e: "13:30", t: "Bio Lecture 3", type: "study" },
            { s: "13:30", e: "14:00", t: "Lunch + Walk", type: "break" },

            // Core Zone (Locked)
            { s: "14:00", e: "14:45", t: "ðŸŽ¯ Biology MCQs", type: "study" },
            { s: "14:45", e: "15:00", t: "Break", type: "break" },
            { s: "15:00", e: "15:45", t: "ðŸŽ¯ Chemistry MCQs", type: "study" },
            { s: "15:45", e: "16:00", t: "Break", type: "break" },
            { s: "16:00", e: "16:45", t: "ðŸŽ¯ Physics MCQs", type: "study" },
            { s: "16:45", e: "17:00", t: "Break", type: "break" },

            // Evening - Chemistry
            { s: "17:00", e: "17:45", t: "Chem Lecture 1", type: "study" },
            { s: "17:45", e: "18:00", t: "Break", type: "break" },
            { s: "18:00", e: "18:45", t: "Chem QP + Revision", type: "study" },
            { s: "18:45", e: "19:00", t: "Break", type: "break" },
            { s: "19:00", e: "19:45", t: "Chem Lecture 2", type: "study" },
            { s: "19:45", e: "20:00", t: "Dinner", type: "break" },

            // Night - Physics
            { s: "20:00", e: "20:45", t: "Physics Lecture 1", type: "study" },
            { s: "20:45", e: "21:00", t: "Break", type: "break" },
            { s: "21:00", e: "21:45", t: "Physics QP + Revision", type: "study" },
            { s: "21:45", e: "22:00", t: "Break", type: "break" },
            { s: "22:00", e: "22:45", t: "Physics Lecture 2", type: "study" },
            { s: "22:45", e: "23:00", t: "Break", type: "break" },
            { s: "23:00", e: "23:45", t: "Physics Notes / Formula", type: "study" },
            { s: "23:45", e: "23:59", t: "Shutdown / Planning", type: "study" }
        ];

        // --- STATE VARIABLES ---
        let timerInterval = null;
        let timeRemaining = 0; // in seconds
        let isPaused = true;
        let currentSlotIndex = -1;

        // --- INITIALIZATION ---
        function init() {
            renderSchedule();
            updateClock();
            setInterval(updateClock, 1000);
            checkScheduleAlignment(); // Check which slot we are in
            setInterval(checkScheduleAlignment, 30000); // Check alignment every 30s
            updateProgress();
        }

        // --- CORE FUNCTIONS ---

        function renderSchedule() {
            const list = document.getElementById('schedule-list');
            list.innerHTML = '';

            rawSchedule.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = `schedule-item ${item.type}`;
                div.id = `slot-${index}`;
                div.innerHTML = `
                    <div class="time-col">${item.s}</div>
                    <div class="task-col">${item.t}</div>
                    <input type="checkbox" onchange="updateProgress(this)">
                `;
                list.appendChild(div);
            });
        }

        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { hour12: false });
            document.getElementById('clock').innerText = timeString;
        }

        function getMinutesFromMidnight(timeStr) {
            const [h, m] = timeStr.split(':').map(Number);
            return h * 60 + m;
        }

        function checkScheduleAlignment() {
            const now = new Date();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();

            let activeFound = false;

            rawSchedule.forEach((item, index) => {
                const startMins = getMinutesFromMidnight(item.s);
                const endMins = getMinutesFromMidnight(item.e);
                const el = document.getElementById(`slot-${index}`);

                // Reset styles
                el.classList.remove('active');

                // Check overlap
                if (currentMinutes >= startMins && currentMinutes < endMins) {
                    activeFound = true;
                    el.classList.add('active');

                    // If we switched to a new slot automatically
                    if (currentSlotIndex !== index) {
                        currentSlotIndex = index;
                        loadSlot(item, startMins, endMins, currentMinutes);
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            if (!activeFound) {
                // Outside schedule hours (Sleep time)
                document.getElementById('current-task-name').innerText = "REST / SLEEP ZONE";
                document.getElementById('current-task-label').innerText = "RECOVER";
            }
        }

        function loadSlot(item, startMins, endMins, currentMinutes) {
            document.getElementById('current-task-name').innerText = item.t;
            document.getElementById('current-task-label').innerText = item.type === 'break' ? "RECHARGE" : "FOCUS MODE";

            // Auto-set timer to remaining duration of the slot
            // Calculate remaining seconds
            const now = new Date();
            const secondsPastMinute = now.getSeconds();
            const totalSlotMinutes = endMins - currentMinutes;

            // Set timer
            timeRemaining = (totalSlotMinutes * 60) - secondsPastMinute;
            if (timeRemaining < 0) timeRemaining = 0;

            updateTimerDisplay();

            // Auto-start timer if desired, or leave paused for manual trigger
            // Prompt says: "Current block should be highlighted automatically".
            // To be distraction-free, let's reset pause state so user hits start to commit.
            pauseTimer();
        }

        // --- TIMER LOGIC ---

        function updateTimerDisplay() {
            const m = Math.floor(timeRemaining / 60);
            const s = timeRemaining % 60;
            document.getElementById('timer').innerText =
                `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        function startTimer() {
            if (!isPaused) return;
            isPaused = false;
            document.getElementById('timer').style.color = "#fff";

            timerInterval = setInterval(() => {
                if (timeRemaining > 0) {
                    timeRemaining--;
                    updateTimerDisplay();
                } else {
                    playAlarm();
                    pauseTimer();
                    document.getElementById('timer').innerText = "00:00";
                    document.getElementById('timer').classList.add('blink');
                }
            }, 1000);
        }

        function pauseTimer() {
            isPaused = true;
            clearInterval(timerInterval);
            document.getElementById('timer').style.color = "var(--dim-text)";
            document.getElementById('timer').classList.remove('blink');
        }

        function resetTimer() {
            pauseTimer();
            // Re-calculate based on current slot total duration (45 or 15)
            if(currentSlotIndex !== -1) {
                const item = rawSchedule[currentSlotIndex];
                const start = getMinutesFromMidnight(item.s);
                const end = getMinutesFromMidnight(item.e);
                timeRemaining = (end - start) * 60;
                updateTimerDisplay();
            }
        }

        // --- ALARM SYSTEM (Web Audio API - No files needed) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playAlarm() {
            // Simple triple beep
            beep(0, 880, 0.2);
            setTimeout(() => beep(0, 880, 0.2), 300);
            setTimeout(() => beep(0, 880, 0.4), 600);
        }

        function beep(delay, frequency, duration) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = "sine";
            oscillator.frequency.value = frequency;

            const now = audioCtx.currentTime;
            oscillator.start(now + delay);
            oscillator.stop(now + delay + duration);
        }

        // --- UTILS ---

        function updateProgress() {
            const total = rawSchedule.length;
            const checked = document.querySelectorAll('input[type="checkbox"]:checked').length;
            document.getElementById('progress-display').innerText = `Completed: ${checked} / ${total}`;

            // Visual feedback for checkbox parent
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(box => {
                if(box.checked) {
                    box.parentElement.classList.add('completed');
                } else {
                    box.parentElement.classList.remove('completed');
                }
            });
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // Start system
        init();

    </script>
</body>
</html>
